plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
}

def appBaseName = (project.findProperty("APP_BASE_NAME") ?: "stopnet").toString()

// 基于 Git tag 的版本号（形如 v1.0.xxx）
def gitTag = "v1.0.0"
try {
    def proc = ["git", "describe", "--tags", "--match", "v*", "--abbrev=0"].execute(null, rootProject.projectDir)
    proc.waitFor()
    if (proc.exitValue() == 0) {
        gitTag = proc.in.text.trim()
    }
} catch (_) { }
def versionNameFromTag = gitTag?.startsWith("v") ? gitTag.substring(1) : gitTag

android {
    namespace "com.example.stopnet"
    compileSdk 34

    defaultConfig {
        applicationId "com.example.stopnet"
        minSdk 24
        targetSdk 34
        versionCode 1
        // 基于 Git tag 的版本名
        versionName versionNameFromTag
    }

    // 读取签名配置：环境变量优先，gradle.properties 次之，最后回退到 keytool/signing.properties
    def signingProps = new Properties()
    def signingPropsFile = rootProject.file("keytool/signing.properties")
    if (signingPropsFile.exists()) {
        signingProps.load(signingPropsFile.newInputStream())
    }

    // 原 ksPath/ksPass/keyAlias/keyPass 改名，避免与 DSL 属性/方法冲突
    def signingStorePath   = System.getenv("ANDROID_KEYSTORE_PATH")
            ?: (project.findProperty("ANDROID_KEYSTORE_PATH") ?: signingProps.getProperty("storeFile")
            ?: new File(rootProject.projectDir, "keytool/stopnet.jks").absolutePath)
    def signingStorePassword   = System.getenv("ANDROID_KEYSTORE_PASSWORD")
            ?: (project.findProperty("ANDROID_KEYSTORE_PASSWORD") ?: signingProps.getProperty("storePassword"))
    def signingKeyAlias = System.getenv("ANDROID_KEY_ALIAS")
            ?: (project.findProperty("ANDROID_KEY_ALIAS") ?: signingProps.getProperty("keyAlias"))
    def signingKeyPassword  = System.getenv("ANDROID_KEY_PASSWORD")
            ?: (project.findProperty("ANDROID_KEY_PASSWORD") ?: signingProps.getProperty("keyPassword"))

    // 只有在全部值齐全时才创建 release 签名配置
    if (signingStorePath && signingStorePassword && signingKeyAlias && signingKeyPassword) {
        signingConfigs {
            release {
                storeFile file(signingStorePath)
                storePassword signingStorePassword
                keyAlias signingKeyAlias
                keyPassword signingKeyPassword
                v1SigningEnabled true
                v2SigningEnabled true
            }
        }
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            // 仅在签名配置完整时应用
            if (signingStorePath && signingStorePassword && signingKeyAlias && signingKeyPassword) {
                signingConfig signingConfigs.release
            }
        }
        debug {
            minifyEnabled false
            // 不指定签名，使用 Android 默认 debug keystore
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = "17"
    }
    packaging {
        resources {
            pickFirsts += [
                "META-INF/NOTICE.md",
                "META-INF/LICENSE.md",
                "META-INF/NOTICE",
                "META-INF/NOTICE.txt",
                "META-INF/LICENSE",
                "META-INF/LICENSE.txt"
            ]
        }
    }
}

// APK 命名：stopnet-debug.apk / stopnet-release-v{versionName}.apk
androidComponents {
    onVariants(selector().all()) { variant ->
        def buildType = variant.buildType
        // 从 DSL 读取版本名，避免访问不存在的 variant.versionName
        def vn = (android.defaultConfig.versionName ?: versionNameFromTag)
        variant.outputs.each { output ->
            if (buildType == "release") {
                output.outputFileName.set("${appBaseName}-${buildType}-v${vn}.apk")
            } else {
                output.outputFileName.set("${appBaseName}-${buildType}.apk")
            }
        }
    }
}

dependencies {
    implementation "org.jetbrains.kotlin:kotlin-stdlib:1.9.24"
    implementation 'androidx.core:core-ktx:1.13.1'
    implementation 'androidx.appcompat:appcompat:1.7.0'
    implementation 'com.google.android.material:material:1.12.0'
    implementation 'androidx.recyclerview:recyclerview:1.3.2'
    implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.8.4'
    implementation 'com.sun.mail:android-mail:1.6.7'
    implementation 'com.sun.mail:android-activation:1.6.7'
}

// Windows: 指定 SDK 工具与 AVD/包名（可通过 -Pxxx 覆盖）
def emulatorExe = (project.findProperty("emulatorExe") ?: "D:\\programfiles\\Android\\SDK\\emulator\\emulator.exe").toString()
def adbExe      = (project.findProperty("adbExe")      ?: "D:\\programfiles\\Android\\SDK\\platform-tools\\adb.exe").toString()
def avdName     = (project.findProperty("avdName")     ?: "Pixel_6_API_34").toString()
// 优先使用默认配置中的 applicationId，其次允许通过 -PappId 覆盖
def appId       = (project.findProperty("appId") ?: (android.defaultConfig.applicationId ?: "com.example.stopnet")).toString()

// 启动模拟器（若无已连接设备）
tasks.register("startEmulator") {
    doLast {
        def out = new ByteArrayOutputStream()
        exec {
            commandLine(adbExe, "devices")
            standardOutput = out
            ignoreExitValue = true
        }
        def hasDevice = out.toString().readLines().any { it.trim().endsWith("\tdevice") }
        if (hasDevice) {
            println("Device already connected; skip emulator start.")
        } else {
            println("No device detected; starting emulator: ${avdName}")
            // 后台启动避免阻塞 Gradle
            exec {
                commandLine(
                    "cmd", "/c", "start", "", "\"${emulatorExe}\"",
                    "-avd", avdName,
                    "-netdelay", "none",
                    "-netspeed", "full",
                    "-no-snapshot-load",
                    "-no-boot-anim"
                )
            }
        }
    }
}

// 等待设备启动完成（sys.boot_completed=1）
tasks.register("waitForDevice") {
    dependsOn("startEmulator")
    doLast {
        exec { commandLine(adbExe, "start-server"); ignoreExitValue = true }

        def timeoutSec = (project.findProperty("deviceWaitTimeoutSec") ?: "240").toInteger()
        def elapsed = 0

        while (true) {
            def devicesOut = new ByteArrayOutputStream()
            exec {
                commandLine(adbExe, "devices")
                standardOutput = devicesOut
                ignoreExitValue = true
            }
            def connected = devicesOut.toString().readLines().any { it.trim().endsWith("\tdevice") }

            if (connected) {
                def bootOut = new ByteArrayOutputStream()
                exec {
                    commandLine(adbExe, "shell", "getprop", "sys.boot_completed")
                    standardOutput = bootOut
                    ignoreExitValue = true
                }
                if (bootOut.toString().trim() == "1") {
                    println("Emulator boot completed and device is ready.")
                    break
                }
            }

            Thread.sleep(1000)
            elapsed++
            if (elapsed >= timeoutSec) {
                throw new GradleException("Emulator did not boot within ${timeoutSec}s")
            }
        }

        // 打印设备列表以确认连接
        exec { commandLine(adbExe, "devices"); ignoreExitValue = true }
    }
}

// 若已安装旧版 APK 则卸载（未安装则跳过）
tasks.register("uninstallOldApk") {
    dependsOn("waitForDevice")
    doLast {
        def pmOut = new ByteArrayOutputStream()
        exec {
            commandLine(adbExe, "shell", "pm", "list", "packages", appId)
            standardOutput = pmOut
            ignoreExitValue = true
        }
        def installed = pmOut.toString().readLines().any { it.trim() == "package:${appId}" }
        if (installed) {
            println("Uninstalling ${appId} ...")
            exec {
                commandLine(adbExe, "uninstall", appId)
                ignoreExitValue = true
            }
        } else {
            println("${appId} not installed; skip uninstall.")
        }
    }
}

// 让 installDebug/installRelease 在执行前依赖设备就绪与卸载旧版
afterEvaluate {
    tasks.matching { it.name in ["installDebug", "installRelease"] }.all {
        dependsOn("uninstallOldApk")
    }
}

// 在 plugins 与 android 之间或文件末尾添加 Kotlin Toolchain
kotlin {
    // 统一使用 JDK 17 编译 Kotlin
    jvmToolchain(17)
}

// 运行：gradlew.bat :app:installDebugAndLogcat
tasks.register('installDebugAndLogcat') {
    dependsOn 'installDebug'

    doLast {
        // 清空旧日志
        exec { commandLine adbExe, 'logcat', '-c' }

        // 启动应用（按需修改为你的入口 Activity）
        exec { commandLine adbExe, 'shell', 'am', 'start', '-n', "${appId}/.MainActivity" }

        // 轮询获取 PID（最多 10 秒）：先尝试 pidof，失败则回退解析 ps -A
        String pid = null
        int tries = 0
        while (pid == null && tries < 20) {
            def out = new ByteArrayOutputStream()
            exec {
                commandLine adbExe, 'shell', 'pidof', appId
                standardOutput = out
                ignoreExitValue = true
            }
            def candidate = out.toString().trim()
            if (candidate) {
                pid = candidate
            } else {
                def psOut = new ByteArrayOutputStream()
                exec {
                    commandLine adbExe, 'shell', 'ps', '-A'
                    standardOutput = psOut
                    ignoreExitValue = true
                }
                def line = psOut.toString().readLines().find { it.contains(appId) }
                if (line) {
                    def cols = line.trim().split(/\s+/)
                    if (cols.size() > 1) pid = cols[1] // 第二列通常为 PID
                }
            }
            if (pid == null) {
                tries++
                Thread.sleep(500)
            }
        }

        if (pid == null) {
            throw new GradleException("Failed to get PID for ${appId}. Is the app launched?")
        }

        println "Tailing logcat for PID ${pid} (WARN/ERROR + stopnet debug). Press Ctrl+C to stop."
        // 仅输出本应用进程的 WARN/ERROR/崩溃 + 自定义 stopnet 调试日志
        exec {
            commandLine adbExe, 'logcat', '--pid', pid, '-v', 'time', 'stopnet:D', 'AndroidRuntime:E', '*:W'
        }
    }
}

// 全局任务开始/结束日志（适用于 installDebugAndLogcat 及其依赖的所有任务）
gradle.taskGraph.beforeTask { Task task ->
    println "[Task-Start] ${task.path}"
}
gradle.taskGraph.afterTask { Task task, TaskState state ->
    def outcome = state.failure ? "FAILED"
            : (state.skipped ? "SKIPPED"
            : (state.upToDate ? "UP-TO-DATE" : "SUCCESS"))
    println "[Task-End]   ${task.path} => ${outcome}"
}
