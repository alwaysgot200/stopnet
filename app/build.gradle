plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
}

def appBaseName = (project.findProperty("APP_BASE_NAME") ?: "stopnet").toString()

// 基于 Git tag 的版本号（形如 v1.0.xxx）
def gitTag = "v1.0.0"
try {
    def proc = ["git", "describe", "--tags", "--match", "v*", "--abbrev=0"].execute(null, rootProject.projectDir)
    proc.waitFor()
    if (proc.exitValue() == 0) {
        gitTag = proc.in.text.trim()
    }
} catch (_) { }
def versionNameFromTag = gitTag?.startsWith("v") ? gitTag.substring(1) : gitTag

android {
    namespace "com.example.stopnet"
    compileSdk 34

    defaultConfig {
        applicationId "com.example.stopnet"
        minSdk 24
        targetSdk 34
        versionCode 1
        // 基于 Git tag 的版本名
        versionName versionNameFromTag
    }

    // 读取签名配置：环境变量优先，gradle.properties 次之，最后回退到 keytool/signing.properties
    def signingProps = new Properties()
    def signingPropsFile = rootProject.file("keytool/signing.properties")
    if (signingPropsFile.exists()) {
        signingProps.load(signingPropsFile.newInputStream())
    }

    // 原 ksPath/ksPass/keyAlias/keyPass 改名，避免与 DSL 属性/方法冲突
    def envStore = System.getenv("ANDROID_KEYSTORE_PATH")
    def defaultStore = new File(rootProject.projectDir, "keytool/stopnet.jks").absolutePath
    def propStore = (project.findProperty("ANDROID_KEYSTORE_PATH") ?: signingProps.getProperty("storeFile") ?: defaultStore)
    def signingStorePath   = (envStore && new File(envStore).exists()) ? envStore : propStore
    def signingStorePassword   = System.getenv("ANDROID_KEYSTORE_PASSWORD")
            ?: (project.findProperty("ANDROID_KEYSTORE_PASSWORD") ?: signingProps.getProperty("storePassword"))
    def signingKeyAlias = System.getenv("ANDROID_KEY_ALIAS")
            ?: (project.findProperty("ANDROID_KEY_ALIAS") ?: signingProps.getProperty("keyAlias"))
    def signingKeyPassword  = System.getenv("ANDROID_KEY_PASSWORD")
            ?: (project.findProperty("ANDROID_KEY_PASSWORD") ?: signingProps.getProperty("keyPassword"))

    // 只有在全部值齐全时才创建 release 签名配置
    if (signingStorePath && signingStorePassword && signingKeyAlias && signingKeyPassword) {
        signingConfigs {
            release {
                storeFile file(signingStorePath)
                storePassword signingStorePassword
                keyAlias signingKeyAlias
                keyPassword signingKeyPassword
                v1SigningEnabled true
                v2SigningEnabled true
            }
        }
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            // 仅在签名配置完整时应用
            if (signingStorePath && signingStorePassword && signingKeyAlias && signingKeyPassword) {
                signingConfig signingConfigs.release
            }
        }
        debug {
            minifyEnabled false
            // 不指定签名，使用 Android 默认 debug keystore
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = "17"
    }
    packaging {
        resources {
            pickFirsts += [
                "META-INF/NOTICE.md",
                "META-INF/LICENSE.md",
                "META-INF/NOTICE",
                "META-INF/NOTICE.txt",
                "META-INF/LICENSE",
                "META-INF/LICENSE.txt"
            ]
        }
    }
}

// APK 命名：stopnet-debug.apk / stopnet-release-v{versionName}.apk
androidComponents {
    onVariants(selector().all()) { variant ->
        def buildType = variant.buildType
        // 从 DSL 读取版本名，避免访问不存在的 variant.versionName
        def vn = (android.defaultConfig.versionName ?: versionNameFromTag)
        variant.outputs.each { output ->
            if (buildType == "release") {
                output.outputFileName.set("${appBaseName}-${buildType}-v${vn}.apk")
            } else {
                output.outputFileName.set("${appBaseName}-${buildType}.apk")
            }
        }
    }
}

dependencies {
    implementation "org.jetbrains.kotlin:kotlin-stdlib:1.9.24"
    implementation 'androidx.core:core-ktx:1.13.1'
    implementation 'androidx.appcompat:appcompat:1.7.0'
    implementation 'com.google.android.material:material:1.12.0'
    implementation 'androidx.recyclerview:recyclerview:1.3.2'
    implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.8.4'
    implementation 'androidx.lifecycle:lifecycle-process:2.8.4'   // 新增：提供 ProcessLifecycleOwner
    implementation 'com.sun.mail:android-mail:1.6.7'
    implementation 'com.sun.mail:android-activation:1.6.7'
}

// Windows: 指定 SDK 工具与 AVD/包名（可通过 -Pxxx 覆盖）
def emulatorExe = (project.findProperty("emulatorExe") ?: "D:\\programfiles\\Android\\SDK\\emulator\\emulator.exe").toString()
def adbExe      = (project.findProperty("adbExe")      ?: "D:\\programfiles\\Android\\SDK\\platform-tools\\adb.exe").toString()
def avdName     = (project.findProperty("avdName")     ?: "Pixel_6_API_34").toString()
// 优先使用默认配置中的 applicationId，其次允许通过 -PappId 覆盖
def appId       = (project.findProperty("appId") ?: (android.defaultConfig.applicationId ?: "com.example.stopnet")).toString()

// 启动模拟器（若无已连接设备）
tasks.register("startEmulator") {
    doLast {
        println "[startEmulator] Checking for devices..."
        def out = new ByteArrayOutputStream()
        exec {
            commandLine(adbExe, "devices")
            standardOutput = out
            ignoreExitValue = true
        }
        println "Device check completed"
        
        // 只检查已完全就绪的设备（device状态），offline/unauthorized 视为"正在启动中"
        def hasReadyDevice = out.toString().readLines().any { it =~ /\tdevice$/ }
        def hasStartingDevice = out.toString().readLines().any { it =~ /\t(offline|unauthorized)$/ }
        
        if (hasReadyDevice) {
            println("[startEmulator] Device already ready; skip emulator start.")
            return
        }
        
        if (hasStartingDevice) {
            println("[startEmulator] Device is starting (offline/unauthorized); skip new emulator start.")
            return
        }
        
        // 检查是否已有模拟器进程在运行（避免重复启动）
        def listAvdOut = new ByteArrayOutputStream()
        try {
            exec {
                commandLine(emulatorExe, "-list-avds")
                standardOutput = listAvdOut
                ignoreExitValue = true
            }
            // 验证 AVD 是否存在
            def availableAvds = listAvdOut.toString().readLines().collect { it.trim() }.findAll { it }
            if (!availableAvds.contains(avdName)) {
                println("[startEmulator] ERROR: AVD '${avdName}' not found. Available AVDs: ${availableAvds}")
                println("[startEmulator] Please create AVD or update 'avdName' property in build.gradle")
                return
            }
        } catch (Exception e) {
            println("[startEmulator] WARNING: Cannot verify AVD existence: ${e.message}")
        }
        
        // 校验 emulator 可执行文件路径
        def emuFile = new File(emulatorExe)
        if (!emuFile.exists()) {
            println("[startEmulator] ERROR: Emulator not found at '${emulatorExe}'.")
            println("[startEmulator] Please set correct 'emulatorExe' path via -PemulatorExe=<path>")
            return
        }
        
        println("[startEmulator] Starting emulator: ${avdName}")
        
        // 使用 ProcessBuilder 异步启动，并重定向输出避免缓冲区阻塞
        def logFile = new File(project.buildDir, "emulator-${avdName}.log")
        def processBuilder = new ProcessBuilder(
            emulatorExe,
            "-avd", avdName,
            "-netdelay", "none",
            "-netspeed", "full",
            "-no-snapshot-load",
            "-no-boot-anim",
            "-no-audio",
            "-gpu", "auto"
        )
        processBuilder.directory(new File(emulatorExe).parentFile)
        processBuilder.redirectErrorStream(true)
        processBuilder.redirectOutput(ProcessBuilder.Redirect.appendTo(logFile))
        
        try {
            def process = processBuilder.start()
            println "[startEmulator] Emulator process started (PID may not be accessible from Gradle)"
            println "[startEmulator] Log file: ${logFile.absolutePath}"
            
            // 等待模拟器进程初始化（给足够时间让进程启动窗口）
            Thread.sleep(3000)
            
            // 验证进程是否还在运行
            try {
                def exitValue = process.exitValue()
                println "[startEmulator] WARNING: Emulator process exited immediately with code ${exitValue}"
                println "[startEmulator] Check log file for details: ${logFile.absolutePath}"
            } catch (IllegalThreadStateException e) {
                // 进程仍在运行，这是期望的行为
                println "[startEmulator] Emulator process is running, waiting for ADB connection..."
            }
        } catch (Exception e) {
            println "[startEmulator] ERROR: Failed to start emulator: ${e.message}"
            e.printStackTrace()
            throw new GradleException("Emulator start failed: ${e.message}")
        }
    }
}

// 等待设备启动完成（sys.boot_completed=1）
tasks.register("waitForDevice") {
    dependsOn("startEmulator")
    doLast {
        exec { commandLine(adbExe, "start-server"); ignoreExitValue = true }

        def timeoutSec = (project.findProperty("deviceWaitTimeoutSec") ?: "240").toInteger()
        def elapsed = 0

        while (true) {
            def devicesOut = new ByteArrayOutputStream()
            exec {
                commandLine(adbExe, "devices")
                standardOutput = devicesOut
                ignoreExitValue = true
            }
            // 接受 device/offline/unauthorized，随后再检查 boot_completed
            def connected = devicesOut.toString().readLines().any { it =~ /\t(device|offline|unauthorized)$/ }

            if (connected) {
                def bootOut = new ByteArrayOutputStream()
                exec {
                    commandLine(adbExe, "shell", "getprop", "sys.boot_completed")
                    standardOutput = bootOut
                    ignoreExitValue = true
                }
                if (bootOut.toString().trim() == "1") {
                    println("Emulator boot completed and device is ready.")
                    break
                }
            }

            Thread.sleep(1000)
            elapsed++
            if (elapsed >= timeoutSec) {
                throw new GradleException("Emulator did not boot within ${timeoutSec}s")
            }
        }

        // 打印设备列表以确认连接
        exec { commandLine(adbExe, "devices"); ignoreExitValue = true }
    }
}

// 若已安装旧版 APK 则卸载（未安装则跳过）
tasks.register("uninstallOldApk") {
    dependsOn("waitForDevice")
    doLast {
        def pmOut = new ByteArrayOutputStream()
        exec {
            commandLine(adbExe, "shell", "pm", "list", "packages", appId)
            standardOutput = pmOut
            ignoreExitValue = true
        }
        def installed = pmOut.toString().readLines().any { it.trim() == "package:${appId}" }
        if (installed) {
            println("Uninstalling ${appId} ...")
            exec {
                commandLine(adbExe, "uninstall", appId)
                ignoreExitValue = true
            }
        } else {
            println("${appId} not installed; skip uninstall.")
        }
    }
}

// 让 installDebug/installRelease 在执行前依赖设备就绪与卸载旧版
afterEvaluate {
    tasks.matching { it.name in ["installDebug", "installRelease"] }.all {
        dependsOn("uninstallOldApk")
    }
}

// 在 plugins 与 android 之间或文件末尾添加 Kotlin Toolchain
kotlin {
    // 统一使用 JDK 17 编译 Kotlin
    jvmToolchain(17)
}

// 运行：gradlew.bat :app:installDebugAndLogcat
tasks.register('installDebugAndLogcat') {
    dependsOn 'installDebug'

    doLast {
        println "[installDebugAndLogcat] Starting custom doLast block..."
        println "[installDebugAndLogcat] adbExe = ${adbExe}"
        println "[installDebugAndLogcat] appId = ${appId}"
        
        // 清空旧日志
        println "[installDebugAndLogcat] Clearing logcat..."
        exec { 
            commandLine adbExe, 'logcat', '-c'
            ignoreExitValue = false
        }

        // 启动应用（按需修改为你的入口 Activity）
        println "[installDebugAndLogcat] Launching app: ${appId}/.MainActivity"
        def launchResult = exec { 
            commandLine adbExe, 'shell', 'am', 'start', '-n', "${appId}/.MainActivity"
            ignoreExitValue = true
        }
        println "[installDebugAndLogcat] Launch command exit code: ${launchResult.exitValue}"

        // 轮询获取 PID（最多 10 秒）：先尝试 pidof，失败则回退解析 ps -A
        String pid = null
        int tries = 0
        while (pid == null && tries < 20) {
            def out = new ByteArrayOutputStream()
            exec {
                commandLine adbExe, 'shell', 'pidof', appId
                standardOutput = out
                ignoreExitValue = true
            }
            def candidate = out.toString().trim()
            if (candidate) {
                pid = candidate
            } else {
                def psOut = new ByteArrayOutputStream()
                exec {
                    commandLine adbExe, 'shell', 'ps', '-A'
                    standardOutput = psOut
                    ignoreExitValue = true
                }
                def line = psOut.toString().readLines().find { it.contains(appId) }
                if (line) {
                    def cols = line.trim().split(/\s+/)
                    if (cols.size() > 1) pid = cols[1] // 第二列通常为 PID
                }
            }
            if (pid == null) {
                tries++
                Thread.sleep(500)
            }
        }

        if (pid == null) {
            throw new GradleException("Failed to get PID for ${appId}. Is the app launched?")
        }

        println "Tailing logcat for PID ${pid} (WARN/ERROR + stopnet debug). Press Ctrl+C to stop."
        // 仅输出本应用进程的 WARN/ERROR/崩溃 + 自定义 stopnet 调试日志
        exec {
            commandLine adbExe, 'logcat', '--pid', pid, '-v', 'time', 'stopnet:D', 'AndroidRuntime:E', '*:W'
        }
    }
}

// 全局任务开始/结束日志（适用于 installDebugAndLogcat 及其依赖的所有任务）
gradle.taskGraph.beforeTask { Task task ->
    println "[Task-Start] ${task.path}"
}
gradle.taskGraph.afterTask { Task task, TaskState state ->
    def outcome = state.failure ? "FAILED"
            : (state.skipped ? "SKIPPED"
            : (state.upToDate ? "UP-TO-DATE" : "SUCCESS"))
    println "[Task-End]   ${task.path} => ${outcome}"
}
